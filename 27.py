a = [[int(j) for j in i.split()] for i in open('files/n27'+input()+'.txt').read().splitlines()]
n, k, v, m = a[0][0], a[0][1], a[0][2], a.pop(0)[3]
a = {i[0]: i[1]//v+(1 if i[1]%v else 0) for i in a}
if k in a: a[0] = a.pop(k)
#0
d = [0 for i in range(k)]
#1
if 0 in a: d[0] = a[0]
for i in range(1,m+1):
    if i in a: d[0] += a[i]
    if (-i)%k in a: d[0] += a[(-i)%k]
#2
for i in range(1,k):
    d[i] = d[i-1]+(a[(i+m)%k] if (i+m)%k in a else 0)-(a[(i-m)%k] if (i-m)%k in a else 0)
#3
print(max([d[i] for i in a])) #409 69383

# Переструктурирование данных:
#     Ключ - номер километра с домом
#     Значение - количество упаковок
#     Значение в k-м километре перемещено в 0-й.

# Динамическое программирование:

# 0. Определение: d[i] - количество упаковок с почтой в m-окрестности i-го километра
# 1. Стартовые значения: d[0] = сумма количеств упаковок для домов на
#     километрах от 0 до m и от 0 до -m
# 2. Шаг динамики: d[i] = d[i-1] + новый a[i+m] - лишний a[i-m]
# 3. Ответ: max(d[i]), где i пробегает номера километров с домами
